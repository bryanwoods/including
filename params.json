{"name":"Including","body":"## including\r\n\r\n* An observation: Other languages allow for more granular loading of only desired methods and functions from module code.\r\n* An experiment: How might this be done in Ruby?\r\n* A warning: Running this code in production might not be wise.\r\n\r\n### How does it work?\r\n\r\nLet's say you've got a module:\r\n\r\n```ruby\r\n  module Foo\r\n    def foo\r\n      \"foo\"\r\n    end\r\n  \r\n    def bar\r\n      \"bar\"\r\n    end\r\n  \r\n    def baz\r\n      \"baz\"\r\n    end\r\n  end\r\n```\r\n\r\nAnd you want to mix it in to a class. But wait! the `foo` method might\r\nconflict with some other `foo`!\r\n\r\n```ruby\r\n  class Bar\r\n    including Foo, except: \"foo\"\r\n  end\r\n  \r\n  bar = Bar.new\r\n  bar.bar # \"bar\"\r\n  bar.foo # NoMethodError\r\n```\r\n\r\nThat's basically it. You can pass an array of `only` the methods you'd\r\nlike to mix in, or an array of exceptions, via `except`.\r\n\r\n```ruby\r\n  class Quux\r\n    including Foo, only: [:foo, :baz]\r\n  end\r\n  \r\n  quux = Quux.new\r\n  quux.foo # \"foo\"\r\n  quux.bar # NoMethodError\r\n  quux.baz # \"baz\"\r\n```\r\n\r\n### Installation\r\n``\r\n  gem install including\r\n``\r\n\r\n### Copyright\r\n\r\nCopyright (c) 2012 Bryan Woods. See LICENSE.txt for\r\nfurther details.","tagline":"An experiment to implement granular loading of module code in Ruby","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}